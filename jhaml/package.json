{
  "name": "jhaml",
  "version": "0.0.14",
  "description": "Joe's HTML Abstraction Markup Language, a DSL/template engine to reduce the tedium of copious, partially redundant HTML templates",
  "homepage": "https://github.com/joelangeway/jhaml",
  "author": {
    "name": "Joe Langeway",
    "email": "joelangeway@gmail.com"
  },
  "contributors": [
    {
      "name": "Clint Zehner"
    },
    {
      "name": "Jamal Williams"
    }
  ],
  "keywords": [
    "jhaml",
    "HMTL",
    "haml",
    "joelangeway",
    "HTML Abstraction",
    "template",
    "joe"
  ],
  "bugs": {
    "url": "https://github.com/joelangeway/jhaml/issues"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/joelangeway/jhaml.git"
  },
  "main": "./jhaml",
  "dependencies": {
    "underscore": ">=1.4.4",
    "requirejs": ">=2.1.6",
    "amdefine": ">=0.0.5"
  },
  "bin": {
    "jhamlc": "./jhamlc.js"
  },
  "readme": "jhaml.js\n========\nJhaml.js is a JavaScript implementation of Joe's HTML abstraction markup language, a domain specific language for HTML templating by Joe Langeway.\n\nYou can use it. The license is the MIT license.\n\nJhaml was developed with input from Jamal Williams and Clint Zehner to reduce the tedium of writing copious HTML templates.\n\nWhat Jhaml is\n-------------\nJhaml is a notation for defining named templates which can call to each other like functions, passing named arguments with dynamic scope. Compiling some jhaml notation results in template functions becoming available on a templates object. Other template functions on that object can be called by jhaml templates as though they were also notated in jhaml. A particular application may run many independent instances of jhaml/jhaml-templates-objects.\n\nWhat Jhaml.js is\n----------------\nJhaml.js is a JavaScript implementation of the jhaml notation. It is structured as a require.js module which exports one constructor. To make a jhaml.js object simply \"new\" that constructor. The resulting jhaml.js object will have a templates object as a property and a compile method. Feed jhaml notation to the compile method, and template functions show up on the templates object. See jhaml_tests.html and jhaml_demo.html for example usage.\n\nWhat Jhaml is and is not for\n---------------------\nJhaml is intended to solve the problem of quickly generating and maintaining HTML structure. It purposefully does not make it easy to put policy in templates. It is intended to sit on top of a view model of some sort which will contain any such logic.\n\nIt defines functions which return strings. It does not interact with the DOM. It does not update in place.\n\nThere are lots of JavaScript frameworks. This isn't one of them. It's a DSL for making HTML and it's an opinionated template engine.\n\nHow to get it\n-------------\n    npm install jhaml\nYou can then require jhaml as a node.js module or in the browser as a requirejs module. It currently requires underscore, requirejs, and amdefine. NPM will get all those for you.\n\nBrief tutorial\n--------------\nSee jhaml_tests.js and jhaml_demo.js for the big picture. Here is a quick introduction to the notation.\n\nTemplate functions are defined by \"def\" statements. So this:\n\n    def fDiv { div }\n\nis equivalent to this:\n\n    jhaml.templates.fDiv = function(args) { return '<div></div>'; };\n\nHTML tags are defined by tag names optionally followed by id's, classes, or attributes just as they would be given in a css query. So this:\n\n    li#listItem1.style1.style2[data-item=\"1\"]\n\nwould result in HTML like this:\n\n    <li id=\"listItem1\" class=\"style1 style2\" data-item=\"1\"></li>\n\nTags are given contents with curly braces. So this:\n\n    div { span }\n\nwould result in HTML like this:\n\n    <div><span></span></div>\n\nLiteral HTML can be included between tildes like this:\n\n    div.wrap { span.text { ~Text content~ } }\n\nConsecutive tags or literals are siblings. So this:\n\n    div.wrap { p { ~paragraph 1~ } p { ~paragraph 2~ ~more~ } }\n\nwould result in HTML like this:\n\n    <div class=\"wrap\"><p>paragraph 1</p><p>paragraph 2more</p></div>\n\nArguments can be referenced with an @ sign. So this:\n\n    def fDiv { div { @content.html } }\n\nis equivalent to this:\n\n    jhaml.templates.fDiv = function(args) { return '<div>' + args.content.html + '</div>'; };\n\nArguments can be references and HTML escaped by including a tilde between the @ and the first argument name. So this:\n\n\tdef fText { p.text { @~text } }\n\nis equivalent to this:\n\n    jhaml.templates.fText = function(args) { return '<p class=\"text\">' + htmlEscape(args.text) + '</p>'; };\n\nwhere htmlEscape() does what you'd think it does.\n\nReferences can be used for id's and classes and attribute values like so:\n\n    div#@id.@class1.@class2[data-foo=@foo]\n\nParenthesis can be used when references and multiple class names would be ambiguous like so:\n\n\tdef.style1.@(classes.class1).style3\n\nYou can call into other templates by giving their name followed by a list of named arguments in parenthesis like this:\n\n    def caller { div { callee() } }\n    def caller { div { callee(text: ~a literal for an argument~) } }\n    def caller { div { callee(content: { span { ~a block for an argument~ } } ) } }\n    def caller { div { callee(arg: @a.reference, arg2: \"a second argument in a quote\") } }\n\nYou can \"splat\" multiple arguments by specifying a reference to an object without a name before the named arguments. So this:\n\n    def callee { img[src=@avatar] span { @~username } } def caller { div { callee(@user) } }\n\nwhen called like this\n\n    jhaml.templates.caller( {user: {avatar: \"imageurl\", username: \"myusername\"}})\n\nwould produce this\n\n    <div><img src=\"imageurl\"></img><span>myusername</span></div>\n\nWhite space is totally meaningless and may be omitted or abused except inside literals and quotes where it is exactly preserved.\n\nComments may appear anywhere a tag may or before argument names in a call or after argument values in a call. They begin with \"/*\" and end with \"*/\" and may nest. They are not respected inside quotes or literals. Like so:\n\n    def caller { dev { callee(\n            /* no arguments \n                /* really none */ \n            */\n            ) /*end call to callee */ \n        }\n    }\n\nArrays and objects can be enumerated with a for..in construct so that this:\n    \n    def call1 { for txt in @txts { span { @txt } } }\n\nwhen called with this:\n\n    {txts: ['a', 'b', 'c'] }\n\nwill produce this:\n\n    <span>a</span><span>b</span><span>c</span>\n\nObjects properties are enumerated by the order of their names according to Array.sort. Property names or array indexes are available by simply giving a second iteration variable name. So that this:\n\n    def call1 { for txt, name in @txts { span { @name ~-~ @txt } } }\n\nwhen called with this:\n\n    {txts: {b:'3', a:'2', c:'1'} }\n\nwill produce this:\n\n    <span>a-2</span><span>b-3</span><span>c-1</span>\n\nCommand Line Tool\n-----------------\nTo create HTML assets statically there is a command line tool that NPM will install for you. It is used thusly:\n\n    $ jhamlc --help\n    This is the command line tool for converting jhaml source to HTML. Pass it files containing jhaml source and it outputs HTML. Each file is implicately wrapped in a template definition and the template called after each file. Files are processed in the order the appear. A single - in place of a filename indicates standard input and will cause jhamlc to read stdin to the end and process it as a single file in sequence. To specify a bag of arguments to pass, include a JSON literal object as a command line argument. If no files are given, then standard input is implied as though a single - were given. \n    $ echo \"div { @foo } \" | jhamlc '{\"foo\":\"bar\"}' -\n    <div>bar</div>\n",
  "readmeFilename": "README.md",
  "_id": "jhaml@0.0.14",
  "_from": "jhaml@"
}
